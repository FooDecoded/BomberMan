/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./public/js/Game.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./public/js/Bomb.js":
/*!***************************!*\
  !*** ./public/js/Bomb.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Bomb; });\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity.js */ \"./public/js/Entity.js\");\n/* harmony import */ var _Fire_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fire.js */ \"./public/js/Fire.js\");\n/* harmony import */ var _layers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layers.js */ \"./public/js/layers.js\");\n/* harmony import */ var _Bonus_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bonus.js */ \"./public/js/Bonus.js\");\n\n\n\n\nclass Bomb extends _Entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(pos, strength, game, bombSprite, fireSprite) {\n    super();\n    this.strength = strength;\n    this.pos = pos;\n    this.size = {\n      w: 28,\n      h: 28\n    };\n    this.timer = Date.now();\n    this.timerMax = 3000;\n    this.exploded = false;\n    this.fires = [];\n    this.explodeListener = null;\n    this.game = game;\n    this.sprite = bombSprite; // this.draw(this.game.context);\n\n    this.fireSprite = fireSprite;\n    this.spriteLayer = Object(_layers_js__WEBPACK_IMPORTED_MODULE_2__[\"createSpriteLayer\"])(this);\n    this.game.layers.push(this.spriteLayer); // console.log(this.fireSprite)\n  }\n\n  update(deltaTime) {\n    if (this.exploded) {\n      return;\n    }\n\n    if (Date.now() - this.timer >= 3000) {\n      this.explode();\n    }\n  }\n\n  explode() {\n    this.exploded = true;\n    var positions = this.getDangerPositions();\n\n    for (var i = 0; i < positions.length; i++) {\n      var position = positions[i];\n      this.fire(position);\n      var material = this.game.getTileMaterial(position);\n\n      if (material == 'wood') {\n        var tile = this.game.getTile(position); // debugger\n\n        tile.remove();\n      } else if (material == 'grass') {\n        // Explode bombs in fire\n        for (var j = 0; j < this.game.bombs.length; j++) {\n          var bomb = this.game.bombs[j]; // debugger                    \n\n          if (!bomb.exploded // need to be calculated by\n          && Math.round(bomb.pos.x / 32) * 32 === position.x && Math.round(bomb.pos.y / 32) * 32 === position.y) {\n            bomb.explode();\n          }\n        }\n      }\n    }\n\n    this.remove();\n  }\n\n  getDangerPositions() {\n    var positions = [];\n    positions.push({\n      x: Math.floor(this.pos.x / 32) * 32,\n      y: Math.floor(this.pos.y / 32) * 32\n    });\n\n    for (var i = 0; i < 4; i++) {\n      var dirX;\n      var dirY;\n\n      if (i == 0) {\n        dirX = 1;\n        dirY = 0;\n      } else if (i == 1) {\n        dirX = -1;\n        dirY = 0;\n      } else if (i == 2) {\n        dirX = 0;\n        dirY = 1;\n      } else if (i == 3) {\n        dirX = 0;\n        dirY = -1;\n      }\n\n      for (var j = 1; j <= this.strength; j++) {\n        var explode = true;\n        var last = false;\n        var position = {\n          x: Math.round((this.pos.x + j * dirX * 32) / 32) * 32,\n          y: Math.round((this.pos.y + j * dirY * 32) / 32) * 32\n        };\n        var material = this.game.getTileMaterial(position);\n\n        if (material == 'wall') {\n          explode = false;\n          last = true;\n        } else if (material == 'wood') {\n          explode = true;\n          last = true;\n        }\n\n        if (explode) {\n          positions.push(position);\n        }\n\n        if (last) {\n          break;\n        }\n      }\n    }\n\n    return positions;\n  }\n\n  setExplodeListener(listener) {\n    this.explodeListener = listener;\n  }\n\n  remove() {\n    for (var i = 0; i < this.game.layers.length; i++) {\n      var layer = this.game.layers[i];\n\n      if (this.spriteLayer == layer) {\n        this.game.layers.splice(i, 1);\n      }\n    }\n\n    this.game.player.bombs = this.game.player.bombs.filter(bomb => bomb != this);\n    setTimeout(() => {\n      const fireLength = this.fires.length;\n\n      for (let i = 0; i < fireLength; i++) {\n        const fire = this.fires.pop();\n        fire.remove();\n      }\n    }, 200);\n  }\n\n  fire(position) {\n    var fire = new _Fire_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](position, this, this.game, this.fireSprite);\n    this.fires.push(fire);\n  }\n\n  draw(context) {\n    this.sprite.draw('bomb', context, this.pos.x, this.pos.y);\n  }\n\n}\n\n//# sourceURL=webpack:///./public/js/Bomb.js?");

/***/ }),

/***/ "./public/js/Bonus.js":
/*!****************************!*\
  !*** ./public/js/Bonus.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Bonus; });\n/* harmony import */ var _sprites_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sprites.js */ \"./public/js/sprites.js\");\n/* harmony import */ var _layers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layers.js */ \"./public/js/layers.js\");\n\n\nlet bonusSprites;\nObject(_sprites_js__WEBPACK_IMPORTED_MODULE_0__[\"loadBonusSprite\"])().then(sprites => {\n  bonusSprites = sprites;\n  console.log(bonusSprites);\n});\nclass Bonus {\n  constructor(pos, type, game) {\n    this.type = type;\n    this.pos = pos;\n    this.game = game;\n  }\n\n  draw(context) {\n    bonusSprites.draw(this.type, context, this.pos.x, this.pos.y);\n  }\n\n  remove() {\n    // console.log(this.game.bonuses.length)\n    for (let i = 0; i < this.game.bonuses.length; i++) {\n      let bonus = this.game.bonuses[i];\n\n      if (this == bonus) {\n        // console.log(this.game.bonuses.length)\n        this.game.bonuses.splice(i, 1); // console.log(this.game.bonuses.length)\n\n        this.game.updateBackground = true;\n      }\n    }\n  }\n\n}\n\n//# sourceURL=webpack:///./public/js/Bonus.js?");

/***/ }),

/***/ "./public/js/Compositor.js":
/*!*********************************!*\
  !*** ./public/js/Compositor.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Compositor; });\nclass Compositor {\n  constructor() {\n    this.layers = [];\n  }\n\n  draw(context) {\n    this.layers.forEach(layer => {\n      layer(context);\n    });\n  }\n\n}\n\n//# sourceURL=webpack:///./public/js/Compositor.js?");

/***/ }),

/***/ "./public/js/Controller.js":
/*!*********************************!*\
  !*** ./public/js/Controller.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Controller; });\nconst PRESSED = 1;\nconst RELEASED = 0;\nclass Controller {\n  constructor() {\n    // Holds the current state of a given key\n    this.keyStates = new Map(); // Holds the callback functions for a key code\n\n    this.keyMap = new Map();\n  }\n\n  addMapping(keyCode, callback) {\n    this.keyMap.set(keyCode, callback);\n  }\n\n  handleEvent(event) {\n    const {\n      keyCode\n    } = event;\n\n    if (!this.keyMap.has(keyCode)) {\n      // Did not have key mapped.\n      return;\n    }\n\n    event.preventDefault();\n    const keyState = event.type === 'keydown' ? PRESSED : RELEASED;\n    this.keyStates.set(keyCode, keyState);\n    this.keyMap.get(keyCode)(keyState);\n  }\n\n  listenTo(window) {\n    ['keydown', 'keyup'].forEach(eventName => {\n      window.addEventListener(eventName, event => {\n        this.handleEvent(event);\n      });\n    });\n  }\n\n}\n\n//# sourceURL=webpack:///./public/js/Controller.js?");

/***/ }),

/***/ "./public/js/Enemy.js":
/*!****************************!*\
  !*** ./public/js/Enemy.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Enemy; });\n/* harmony import */ var _layers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layers.js */ \"./public/js/layers.js\");\n\nclass Enemy {\n  constructor(pos, type, ghostSprite, game, vel) {\n    // debugger\n    this.pos = pos;\n    this.direction = {\n      x: 1,\n      y: 0\n    };\n    this.lastDirection = {\n      x: -1,\n      y: 0\n    };\n    this.type = type;\n    this.excludeDirections = [];\n    this.sprite = ghostSprite;\n    this.game = game;\n    this.dirX = 0;\n    this.dirY = -1;\n    this.previousPosition = {};\n    this.targetPosition = {};\n\n    if (type == 'ghost') {\n      // debugger\n      this.vel = .5 * vel;\n    } else {\n      this.vel = .8 * vel;\n    } // this.spriteLayer = spriteLayer\n\n\n    this.size = {\n      w: 32,\n      h: 32\n    };\n    this.spriteLayer = Object(_layers_js__WEBPACK_IMPORTED_MODULE_0__[\"createSpriteLayer\"])(this);\n    this.game.layers.push(this.spriteLayer);\n    this.frameIndex = 1;\n    this.currentFrameCount = 0;\n    this.changeRoute = false;\n    this.currentAxisCount = 0;\n    this.currentFrameIndex = 1;\n    this.animationStartPosition = { ...this.pos\n    };\n    this.changeAxis = false;\n    this.playerDirection = {};\n  }\n\n  draw(context) {\n    let frameName = this.type == 'ghost' ? this.getBallonFrameName() : this.getDeadFrameName();\n    this.sprite.draw(frameName, this.game.context, this.pos.x, this.pos.y);\n  }\n\n  getBallonFrameName() {\n    if (this.currentFrameCount < 75) {\n      this.currentFrameCount++;\n      return `ballon-${this.frameIndex}`;\n    } else {\n      this.currentFrameCount = 0;\n\n      if (this.frameIndex == 6) {\n        this.frameIndex = 1;\n        return `ballon-${this.frameIndex}`;\n      } else {\n        this.frameIndex += 1;\n        return `ballon-${this.frameIndex - 1}`;\n      }\n    }\n  }\n\n  getDeadFrameName() {\n    if (this.direction.x == 1 && this.direction.y == 0) {\n      this.calculateNextFrame();\n      return `dead-right-${Math.ceil(this.currentFrameIndex)}`;\n    } else if (this.direction.x == -1 && this.direction.y == 0) {\n      this.calculateNextFrame();\n      return `dead-left-${Math.ceil(this.currentFrameIndex)}`;\n    } else if (this.direction.x == 0 && this.direction.y == 1) {\n      this.calculateNextFrame();\n      return `dead-down-${Math.ceil(this.currentFrameIndex)}`;\n    } else if (this.direction.x == 0 && this.direction.y == -1) {\n      this.calculateNextFrame();\n      return `dead-top-${Math.ceil(this.currentFrameIndex)}`;\n    }\n  }\n\n  calculateNextFrame() {\n    if (this.direction.x) {\n      let index = Math.round(Math.random() * 3); // Math.abs(this.pos.x - this.animationStartPosition.x ) % 4\n\n      this.currentFrameIndex = index < 1 ? 1 : index;\n    } else {\n      let index = Math.round(Math.random() * 3); // Math.abs(this.pos.y - this.animationStartPosition.y ) % 3\n\n      this.currentFrameIndex = index < 1 ? 1 : index;\n    }\n  }\n\n  setPlayerDirection() {\n    let distance = {\n      x: this.pos.x - this.game.player.pos.x,\n      y: this.pos.y - this.game.player.pos.y\n    };\n    this.playerDirection.x = distance.x < 1 ? 1 : -1;\n    this.playerDirection.y = distance.y < 1 ? 1 : -1;\n  }\n\n  getToPlayer() {\n    let availableDirections = this.availableDirections();\n\n    if (this.direction.x != 0) {\n      // change to Y\n      for (let i = 0; i < availableDirections.length; i++) {\n        if (availableDirections[i].y === this.playerDirection.y) {\n          // debugger\n          this.lastDirection = { ...this.direction\n          };\n          this.direction = { ...availableDirections[i]\n          };\n          this.changeAxis = false;\n        }\n      }\n    } else {\n      // Change to X\n      for (let i = 0; i < availableDirections.length; i++) {\n        if (availableDirections[i].x === this.playerDirection.x) {\n          // debugger\n          this.lastDirection = { ...this.direction\n          };\n          this.direction = { ...availableDirections[i]\n          };\n          this.changeAxis = false;\n        }\n      }\n    }\n  }\n\n  update() {\n    this.setPlayerDirection();\n    this.detectPlayerCollision();\n\n    if (this.detectWallCollision(this.direction)) {\n      this.lastDirection = {\n        x: this.direction.x * -1,\n        y: this.direction.y * -1\n      };\n      let nextDIrection = this.findNextDirection();\n      this.direction = nextDIrection;\n\n      if (!(this.direction.x == this.playerDirection.x || this.direction.y == this.playerDirection.y)) {\n        // debugger\n        this.changeAxis = true;\n      }\n\n      this.animationStartPosition = { ...this.pos\n      };\n      this.pos.x = this.myTileCorner().x;\n      this.pos.y = this.myTileCorner().y;\n    } else if (this.detectBombCollision()) {\n      // debugger\n      // debugger\n      this.lastDirection = { ...this.direction\n      };\n      this.direction = {\n        x: this.direction.x * -1,\n        y: this.direction.y * -1\n      };\n      this.animationStartPosition = { ...this.pos\n      };\n    } else if (this.changeAxis && this.type == 'dead') {\n      this.getToPlayer();\n    }\n\n    this.pos.x = this.pos.x + this.direction.x * this.vel;\n    this.pos.y = this.pos.y + this.direction.y * this.vel;\n  }\n\n  myTileCorner() {\n    return {\n      x: Math.round(this.pos.x / 32) * 32,\n      y: Math.round(this.pos.y / 32) * 32\n    };\n  }\n\n  availableDirections() {\n    let tilesDirections = [[1, 0], // right\n    [-1, 0], // left\n    [0, -1], // up\n    [0, 1] // down\n    ];\n    let currentTile = this.myTileCorner();\n    let availableDirections = [];\n\n    for (let i = 0; i < tilesDirections.length; i++) {\n      // const element = array[i];\n      // debugger\n      this.game.getTileMaterial({\n        x: currentTile.x + tilesDirections[i][0] * 32,\n        y: currentTile.y + tilesDirections[i][1] * 32\n      }) === 'grass' ? availableDirections.push({\n        x: tilesDirections[i][0],\n        y: tilesDirections[i][1]\n      }) : null;\n    } // console.log(availableSpaces)\n\n\n    return availableDirections;\n  }\n\n  findNextDirection() {\n    let availableDirs = this.availableDirections(); // console.log(availableDirs)\n\n    if (availableDirs.length === 1) {\n      return availableDirs[0];\n    } else {\n      availableDirs = availableDirs.filter(dir => {\n        return !(dir.x == this.lastDirection.x && dir.y == this.lastDirection.y);\n      });\n      return availableDirs[Math.floor(Math.random() * availableDirs.length)];\n    }\n  }\n\n  intersectRect(a, b) {\n    if (a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y) {\n      // collision detected!\n      return true;\n    }\n\n    return false;\n  }\n\n  detectBombCollision() {\n    let bombBox = {};\n\n    for (let i = 0; i < this.game.player.bombs.length; i++) {\n      // debugger\n      bombBox = { ...this.game.player.bombs[i].pos\n      };\n      bombBox.height = this.game.player.bombs[i].size.h;\n      bombBox.width = this.game.player.bombs[i].size.w;\n    }\n\n    var ballonBox = { ...this.pos\n    };\n    ballonBox.width = this.size.w;\n    ballonBox.height = this.size.h;\n\n    if (this.intersectRect(ballonBox, bombBox)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  detectPlayerCollision() {\n    var ballonBox = { ...this.pos\n    };\n    var playerBox = { ...this.game.player.pos\n    };\n    ballonBox.width = this.size.w;\n    ballonBox.height = this.size.h;\n    playerBox.width = this.game.player.size.w;\n    playerBox.height = this.game.player.size.h;\n\n    if (this.intersectRect(ballonBox, playerBox)) {\n      this.game.player.kill();\n    }\n  }\n\n  detectWallCollision(direction) {\n    let nextPosition = {};\n    nextPosition.x = this.pos.x + direction.x * 2;\n    nextPosition.y = this.pos.y + direction.y * 2;\n    nextPosition.width = 32;\n    nextPosition.height = 32;\n    var tiles = this.game.tiles;\n\n    for (var i = 0; i < tiles.length; i++) {\n      if (tiles[i].material == 'grass') {\n        continue;\n      }\n\n      var tilePosition = tiles[i].pos;\n      var tileBox = {};\n      tileBox.x = tilePosition.x;\n      tileBox.y = tilePosition.y;\n      tileBox.width = 32;\n      tileBox.height = 32;\n\n      if (this.intersectRect(nextPosition, tileBox, direction)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  remove() {\n    for (var i = 0; i < this.game.layers.length; i++) {\n      var layer = this.game.layers[i];\n\n      if (this.spriteLayer == layer) {\n        // debugger\n        this.game.layers.splice(i, 1);\n      }\n    }\n\n    for (var i = 0; i < this.game.enemies.length; i++) {\n      var enemy = this.game.enemies[i];\n\n      if (this == enemy) {\n        // debugger\n        this.game.enemies.splice(i, 1);\n      }\n    }\n  }\n\n}\n\n//# sourceURL=webpack:///./public/js/Enemy.js?");

/***/ }),

/***/ "./public/js/Entity.js":
/*!*****************************!*\
  !*** ./public/js/Entity.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Entity; });\nclass Vector {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n}\n\nclass Entity {\n  constructor() {\n    this.pos = new Vector(0, 0);\n    this.vel = 0;\n    this.moving = false;\n  }\n\n  update(deltaTime) {// this.traits.forEach(trait => {\n    //     trait.update(this, deltaTime);\n    // });\n  }\n\n}\n\n//# sourceURL=webpack:///./public/js/Entity.js?");

/***/ }),

/***/ "./public/js/Fire.js":
/*!***************************!*\
  !*** ./public/js/Fire.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Fire; });\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity.js */ \"./public/js/Entity.js\");\n/* harmony import */ var _layers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layers.js */ \"./public/js/layers.js\");\n\n\nclass Fire {\n  constructor(pos, bomb, game, sprite) {\n    this.pos = pos;\n    this.size = {\n      w: 32,\n      h: 32\n    };\n    this.bomb = bomb;\n    this.game = game;\n    this.sprite = sprite;\n    this.spriteLayer = Object(_layers_js__WEBPACK_IMPORTED_MODULE_1__[\"createSpriteLayer\"])(this);\n    this.game.layers.push(this.spriteLayer);\n    this.killCollidableObjects();\n  }\n\n  draw(context) {\n    this.sprite.draw('fire', context, this.pos.x, this.pos.y);\n  }\n\n  intersectRect(a, b) {\n    // debugger\n    if (a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y) {\n      // collision detected!\n      return true;\n    }\n\n    return false;\n  }\n\n  killCollidableObjects() {\n    let fireBox = {\n      x: this.pos.x,\n      y: this.pos.y,\n      width: 32,\n      height: 32\n    };\n    this.game.enemies.forEach(enemy => {\n      if (this.intersectRect(fireBox, {\n        x: enemy.pos.x,\n        y: enemy.pos.y,\n        height: enemy.size.h,\n        width: enemy.size.w\n      })) {\n        enemy.remove();\n      }\n    });\n    let playerBox = { ...this.game.player.pos\n    };\n    playerBox.width = this.game.player.size.w;\n    playerBox.height = this.game.player.size.h;\n\n    if (this.intersectRect(fireBox, playerBox)) {\n      this.game.player.kill();\n    }\n  }\n\n  remove() {\n    for (var i = 0; i < this.game.layers.length; i++) {\n      var layer = this.game.layers[i];\n\n      if (this.spriteLayer == layer) {\n        this.game.layers.splice(i, 1);\n      }\n    }\n  }\n\n}\n\n//# sourceURL=webpack:///./public/js/Fire.js?");

/***/ }),

/***/ "./public/js/Game.js":
/*!***************************!*\
  !*** ./public/js/Game.js ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Compositor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Compositor.js */ \"./public/js/Compositor.js\");\n/* harmony import */ var _sprites_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sprites.js */ \"./public/js/sprites.js\");\n/* harmony import */ var _layers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layers.js */ \"./public/js/layers.js\");\n/* harmony import */ var _Player_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Player.js */ \"./public/js/Player.js\");\n/* harmony import */ var _Enemy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Enemy.js */ \"./public/js/Enemy.js\");\n/* harmony import */ var _Controller_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Controller.js */ \"./public/js/Controller.js\");\n/* harmony import */ var _Levels_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Levels.js */ \"./public/js/Levels.js\");\n/* harmony import */ var _loaders_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./loaders.js */ \"./public/js/loaders.js\");\n\n\n\n\n\n\n\n\n\nconsole.log('gammmmme');\n\nclass Game {\n  constructor() {\n    this.canvas = document.getElementById('screen');\n    this.context = this.canvas.getContext('2d');\n    this.tiles = [];\n    this.layers = null;\n    this.bombs = [];\n    this.bonuses = [];\n    this.enemies = [];\n    this.bonusesPercent = 75;\n    this.player = null;\n    this.updateBackground = false;\n    this.loadGame();\n    this.update = this.update.bind(this);\n    this.isPlaying = false;\n    this.gameStarted = true;\n    this.level = 1;\n    this.gameOver = false;\n    this.alreadyLoaded = false;\n  }\n\n  createEnimies() {\n    _Levels_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"][this.level].enemies.forEach(enemy => {\n      if (enemy.type == 'ghost') {\n        this.enemies.push(new _Enemy_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({ ...enemy.pos\n        }, enemy.type, this.ghostSprite, this, _Levels_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"][this.level].enemiesSpeed));\n      } else if (enemy.type == 'dead') {\n        this.enemies.push(new _Enemy_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({ ...enemy.pos\n        }, enemy.type, this.deadSprite, this, _Levels_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"][this.level].enemiesSpeed));\n      }\n    });\n  }\n\n  getApproximateTile(position) {\n    for (var i = 0; i < this.tiles.length; i++) {\n      var tile = this.tiles[i];\n\n      if (tile.pos.x > Math.floor(position.x / 32) && tile.pos.y > Math.floor(position.y / 32)) {\n        return tile;\n      }\n    }\n\n    return {\n      material: 'grass'\n    };\n  }\n\n  getTileMaterial(position) {\n    var tile = this.getTile(position);\n    return tile ? tile.material : 'grass';\n  }\n\n  getTile(position) {\n    for (var i = 0; i < this.tiles.length; i++) {\n      var tile = this.tiles[i];\n\n      if (tile.pos.x == position.x && tile.pos.y == position.y) {\n        return tile;\n      }\n    }\n  }\n\n  setupKeys() {\n    const SPACE = 32;\n    const UP = 38;\n    const DOWN = 40;\n    const RIGHT = 39;\n    const LEFT = 37;\n    const ESC = 27;\n    let keyboardMap = {\n      up: false,\n      down: false,\n      left: false,\n      right: false,\n      space: false\n    };\n    window.addEventListener('keydown', e => {\n      if (this.isPlaying) {\n        e.preventDefault();\n\n        if (e.keyCode === UP) {\n          this.player.moving = true;\n          this.player.direction = {\n            x: 0,\n            y: -1\n          };\n        } else if (e.keyCode === DOWN) {\n          this.player.moving = true;\n          this.player.direction = {\n            x: 0,\n            y: 1\n          };\n        } else if (e.keyCode === RIGHT) {\n          this.player.moving = true;\n          this.player.direction = {\n            x: 1,\n            y: 0\n          };\n        } else if (e.keyCode === LEFT) {\n          this.player.moving = true;\n          this.player.direction = {\n            x: -1,\n            y: 0\n          };\n        } else if (e.keyCode === SPACE) {\n          this.player.setBombsListener();\n          this.player.update();\n        }\n      }\n    });\n    window.addEventListener('keyup', e => {\n      if (this.isPlaying) {\n        if (e.keyCode === UP) {\n          keyboardMap.up = false;\n          this.player.stop();\n        } else if (e.keyCode === DOWN) {\n          keyboardMap.down = false;\n          this.player.stop();\n        } else if (e.keyCode === RIGHT) {\n          keyboardMap.right = false;\n          this.player.stop();\n        } else if (e.keyCode === LEFT) {\n          keyboardMap.left = false;\n          this.player.stop();\n        }\n      }\n\n      if (e.keyCode === ESC) {\n        if (this.gameOver) {\n          // debugger\n          this.level = 1; // this.loadGame()\n\n          this.setUpLevel();\n        } else {\n          this.toggleMenu();\n        }\n      }\n    });\n  }\n\n  emptyScreen() {\n    this.layers = [];\n  }\n\n  toggleMenu() {\n    if (this.isPlaying) {\n      this.isPlaying = false;\n    } else {\n      this.isPlaying = true;\n    }\n  }\n\n  drawMenu() {\n    this.context.drawImage(this.pauseImg, 240, 170);\n    this.context.font = \"bold 30px Georgia\";\n    this.context.fillStyle = 'black';\n    this.context.fillText(`Hit 'ESC' to continue`, 130, 200 + 60);\n  }\n\n  drawGameOver() {\n    this.context.drawImage(this.gameOverImg, 200, 150);\n    this.context.font = \"bold 30px Georgia\";\n    this.context.fillStyle = 'black';\n    this.context.fillText(`Hit 'ESC' to try again!`, 130, 200 + 95);\n  }\n\n  handleLevelChange() {\n    this.level += 1;\n    this.setUpLevel();\n  }\n\n  drawGameInfo() {\n    // this.context.fillStyle = \"#E5AA2B\"\n    this.context.font = \"bold 20px Georgia\";\n    this.context.fillStyle = '#CAC7C2';\n    this.context.fillText(`Level: ${this.level}  Hearts: ${this.player.lives}`, 200, 20);\n  }\n\n  update() {\n    if (this.isPlaying) {\n      if (!this.player.lives <= 0 && !this.gameOver) {\n        if (this.enemies.length == 0 && !this.gameOver) {\n          this.handleLevelChange();\n        } // debugger\n        // console.log('innnnnnnnnnnnnnnn')\n        // debugger\n\n\n        this.bombs.forEach(bomb => bomb.update());\n        this.enemies.forEach(enemy => enemy.update());\n        this.player.update();\n        this.comp.draw(this.context);\n        this.drawGameInfo();\n      } else {\n        this.comp.draw(this.context);\n        this.drawGameOver();\n      }\n    } else if (!this.isPlaying && !this.gameOver) {\n      this.comp.draw(this.context);\n      this.drawMenu();\n    } else if (this.gameOver && !this.isPlaying) {\n      this.drawGameOver();\n    }\n\n    requestAnimationFrame(this.update);\n  }\n\n  showMenu() {}\n\n  setUpLevel() {\n    this.player.pos = {\n      x: 32,\n      y: 32\n    };\n    this.player.bombsMax = 1;\n    this.player.bombStrength = 1;\n    this.player.velocity = 1;\n    this.bonuses = [];\n    this.bombs = [];\n    this.tiles = [];\n    this.enemies = [];\n    this.level > 1 && this.layers.shift(); // debugger\n\n    if (this.gameOver) {\n      this.comp.layers = [];\n      this.layers = this.comp.layers;\n      this.layers.push(this.playerSpriteLayer);\n      this.gameOver = false;\n      this.isPlaying = true;\n      this.player.lives = 3;\n    }\n\n    this.layers.unshift(Object(_layers_js__WEBPACK_IMPORTED_MODULE_2__[\"createBackgroundLayer\"])(this.backgroundSprites, this.tiles, this)); // debugger\n\n    this.createEnimies();\n\n    if (!this.gameOver && !this.alreadyLoaded) {\n      this.update();\n      this.alreadyLoaded = true;\n      this.isPlaying = false;\n    }\n  }\n\n  loadGame() {\n    Promise.all([Object(_Player_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this), Object(_sprites_js__WEBPACK_IMPORTED_MODULE_1__[\"loadBackgroundSprites\"])(), Object(_sprites_js__WEBPACK_IMPORTED_MODULE_1__[\"loadGhostSprite\"])(), Object(_sprites_js__WEBPACK_IMPORTED_MODULE_1__[\"loadDeadSprite\"])(), Object(_loaders_js__WEBPACK_IMPORTED_MODULE_7__[\"loadImage\"])('./img/pause.png'), Object(_loaders_js__WEBPACK_IMPORTED_MODULE_7__[\"loadImage\"])('./img/game-over.png')]).then(([player, backgroundSprites, ghostSprite, deadSprite, pauseImg, gameOverImg]) => {\n      // debugger\n      this.pauseImg = pauseImg;\n      this.ghostSprite = ghostSprite;\n      this.deadSprite = deadSprite;\n      this.gameOverImg = gameOverImg;\n      this.enemies = [];\n      this.bombs = [];\n      this.gameOver = false;\n      this.isPlaying = true;\n      !this.alreadyLoaded && this.setupKeys();\n      this.comp = new _Compositor_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n      this.layers = this.comp.layers;\n      this.playerSpriteLayer = Object(_layers_js__WEBPACK_IMPORTED_MODULE_2__[\"createSpriteLayer\"])(player);\n      this.layers.push(this.playerSpriteLayer);\n      this.player = player;\n      this.backgroundSprites = backgroundSprites;\n      this.setUpLevel();\n    });\n  }\n\n}\n\nnew Game();\n\n//# sourceURL=webpack:///./public/js/Game.js?");

/***/ }),

/***/ "./public/js/Levels.js":
/*!*****************************!*\
  !*** ./public/js/Levels.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst Levels = {\n  1: {\n    bonusesPercent: 75,\n    enemies: [{\n      pos: {\n        x: 32 * 15,\n        y: 32\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32,\n        y: 32 * 11\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32 * 15,\n        y: 32 * 11\n      },\n      type: 'ghost'\n    }],\n    enemiesSpeed: 1\n  },\n  2: {\n    bonusesPercent: 65,\n    enemies: [{\n      pos: {\n        x: 32 * 15,\n        y: 32\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32,\n        y: 32 * 11\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32 * 15,\n        y: 32 * 11\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32 * 11,\n        y: 32 * 3\n      },\n      type: 'dead'\n    }, {\n      pos: {\n        x: 32 * 11,\n        y: 32 * 9\n      },\n      type: 'dead'\n    }],\n    enemiesSpeed: 1\n  },\n  3: {\n    bonusesPercent: 65,\n    enemies: [{\n      pos: {\n        x: 32 * 15,\n        y: 32\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32,\n        y: 32 * 11\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32 * 15,\n        y: 32 * 11\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32 * 11,\n        y: 32 * 3\n      },\n      type: 'dead'\n    }, {\n      pos: {\n        x: 32 * 11,\n        y: 32 * 9\n      },\n      type: 'dead'\n    }, {\n      pos: {\n        x: 32 * 13,\n        y: 32 * 3\n      },\n      type: 'dead'\n    }, {\n      pos: {\n        x: 32 * 11,\n        y: 32 * 3\n      },\n      type: 'dead'\n    }],\n    enemiesSpeed: 2\n  },\n  4: {\n    bonusesPercent: 65,\n    enemies: [{\n      pos: {\n        x: 32 * 15,\n        y: 32\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32,\n        y: 32 * 11\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32 * 15,\n        y: 32 * 11\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32 * 11,\n        y: 32 * 3\n      },\n      type: 'dead'\n    }, {\n      pos: {\n        x: 32 * 11,\n        y: 32 * 9\n      },\n      type: 'dead'\n    }, {\n      pos: {\n        x: 32 * 13,\n        y: 32 * 3\n      },\n      type: 'dead'\n    }, {\n      pos: {\n        x: 32 * 11,\n        y: 32 * 3\n      },\n      type: 'dead'\n    }],\n    enemiesSpeed: 3\n  },\n  5: {\n    bonusesPercent: 65,\n    enemies: [{\n      pos: {\n        x: 32 * 15,\n        y: 32\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32,\n        y: 32 * 11\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32 * 15,\n        y: 32 * 11\n      },\n      type: 'ghost'\n    }, {\n      pos: {\n        x: 32 * 11,\n        y: 32 * 3\n      },\n      type: 'dead'\n    }, {\n      pos: {\n        x: 32 * 11,\n        y: 32 * 9\n      },\n      type: 'dead'\n    }, {\n      pos: {\n        x: 32 * 13,\n        y: 32 * 3\n      },\n      type: 'dead'\n    }, {\n      pos: {\n        x: 32 * 11,\n        y: 32 * 3\n      },\n      type: 'dead'\n    }],\n    enemiesSpeed: 3\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Levels);\n\n//# sourceURL=webpack:///./public/js/Levels.js?");

/***/ }),

/***/ "./public/js/Player.js":
/*!*****************************!*\
  !*** ./public/js/Player.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return createPlayer; });\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity.js */ \"./public/js/Entity.js\");\n/* harmony import */ var _sprites_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sprites.js */ \"./public/js/sprites.js\");\n/* harmony import */ var _Bomb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bomb.js */ \"./public/js/Bomb.js\");\n\n\n\n\nclass Player extends _Entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(sprites, game) {\n    super();\n    this.game = game;\n    this.bombSprite = sprites.bombSprite;\n    this.sprite = sprites.playerSprite;\n    this.fireSprite = sprites.fireSprite;\n    this.bombsMax = 1;\n    this.bombStrength = 1;\n    this.velocity = 1;\n    this.size = {\n      w: 24,\n      h: 24\n    };\n    this.alive = true;\n    this.bombs = [];\n    this.direction = '';\n    this.moving = false;\n    this.currentFrameIndex = 1;\n    this.animationStartPosition = { ...this.pos\n    };\n    this.lives = 3;\n  }\n\n  getFrameName() {\n    if (this.moving && this.direction.x == 1 && this.direction.y == 0) {\n      this.calculateNextFrame();\n      return `right-${Math.floor(this.currentFrameIndex)}`;\n    } else if (this.moving && this.direction.x == -1 && this.direction.y == 0) {\n      this.calculateNextFrame();\n      return `left-${Math.floor(this.currentFrameIndex)}`;\n    } else if (this.moving && this.direction.x == 0 && this.direction.y == 1) {\n      this.calculateNextFrame();\n      return `down-${Math.floor(this.currentFrameIndex)}`;\n    } else if (this.moving && this.direction.x == 0 && this.direction.y == -1) {\n      this.calculateNextFrame();\n      return `top-${Math.floor(this.currentFrameIndex)}`;\n    } else if (!this.moving) {\n      return `idle`;\n    }\n  }\n\n  calculateNextFrame() {\n    if (this.direction.x) {\n      this.currentFrameIndex = Math.abs(this.pos.x - this.animationStartPosition.x) % 3;\n    } else {\n      this.currentFrameIndex = Math.abs(this.pos.y - this.animationStartPosition.y) % 3;\n    }\n  }\n\n  kill() {\n    // console.log('I got killed')\n    this.lives -= 1;\n\n    if (this.lives > 0) {\n      this.resurrect();\n    } else {\n      this.game.gameOver = true;\n      this.game.isPlaying = false;\n    }\n  }\n\n  resurrect() {\n    // this.pos = {}\n    this.pos = {\n      x: -100,\n      y: -100\n    };\n    setTimeout(() => {\n      this.pos = {\n        x: 32,\n        y: 32\n      };\n    }, 750); // this.pos = {x: 32, y: 32}\n  }\n\n  draw(context) {\n    // debugger\n    let frameName = this.getFrameName(); // console.log(frameName)\n    // console.log(frameName)\n    // console.log('innnnnnnnnnnnnnnnnnnnnn')\n    // console.log(frameName)\n\n    this.sprite.draw(frameName, this.game.context, this.pos.x, this.pos.y);\n  }\n\n  myTileCorner() {\n    return {\n      x: Math.round(this.pos.x / 32) * 32,\n      y: Math.round(this.pos.y / 32) * 32\n    };\n  }\n\n  update() {\n    if (this.moving) {\n      // debugger\n      if (this.direction.x == 1 && this.direction.y == 0) {\n        this.moveRight();\n      } else if (this.direction.x == -1 && this.direction.y == 0) {\n        this.moveLeft();\n      } else if (this.direction.x == 0 && this.direction.y == -1) {\n        this.moveUp();\n      } else if (this.direction.x == 0 && this.direction.y == 1) {\n        this.moveDown();\n      }\n    }\n  }\n\n  adjacenrFreeTiles() {\n    let tilesDirections = [[1, 0], // right\n    [-1, 0], // left\n    [0, -1], // up\n    [0, 1] // down\n    ];\n    let currentTile = this.myTileCorner();\n    let availableSpaces = [];\n\n    for (let i = 0; i < tilesDirections.length; i++) {\n      // const element = array[i];\n      // debugger\n      this.game.getTileMaterial({\n        x: currentTile.x + tilesDirections[i][0] * 32,\n        y: currentTile.y + tilesDirections[i][1] * 32\n      }) === 'grass' ? availableSpaces.push({\n        x: currentTile.x + tilesDirections[i][0] * 32,\n        y: currentTile.y + tilesDirections[i][1] * 32\n      }) : null;\n    } // console.log(availableSpaces)\n\n\n    return availableSpaces;\n  }\n\n  moveUp() {\n    if (this.detectWallCollision({\n      x: 0,\n      y: -1\n    })) {\n      return;\n    }\n\n    ;\n\n    if (!this.animationStartPosition) {\n      this.animationStartPosition = { ...this.pos\n      };\n    }\n\n    this.handleBonusCollision();\n    this.vel = -this.velocity;\n    this.pos.y += this.vel;\n  }\n\n  moveRight() {\n    if (this.detectWallCollision({\n      x: 1,\n      y: 0\n    })) {\n      return;\n    }\n\n    ;\n\n    if (!this.animationStartPosition) {\n      this.animationStartPosition = { ...this.pos\n      };\n    }\n\n    this.handleBonusCollision();\n    this.vel = this.velocity;\n    this.pos.x += this.vel;\n  }\n\n  moveDown() {\n    if (this.detectWallCollision({\n      x: 0,\n      y: 1\n    })) {\n      return;\n    }\n\n    ;\n\n    if (!this.animationStartPosition) {\n      this.animationStartPosition = { ...this.pos\n      };\n    }\n\n    this.handleBonusCollision();\n    this.vel = this.velocity;\n    this.pos.y += this.vel;\n  }\n\n  moveLeft() {\n    if (this.detectWallCollision({\n      x: -1,\n      y: 0\n    })) {\n      return;\n    }\n\n    ;\n\n    if (!this.animationStartPosition) {\n      this.animationStartPosition = { ...this.pos\n      };\n    }\n\n    this.handleBonusCollision();\n    this.vel = -this.velocity;\n    this.pos.x += this.vel;\n  }\n\n  stop() {\n    this.moving = false;\n    this.animationStartPosition = null;\n  }\n\n  intersectRect(a, b) {\n    if (a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y) {\n      // collision detected!\n      return true;\n    }\n\n    return false;\n  }\n\n  detectWallCollision(direction) {\n    let nextPosition = {};\n    nextPosition.x = this.pos.x + direction.x * this.velocity;\n    nextPosition.y = this.pos.y + direction.y * this.velocity;\n    nextPosition.width = this.size.w;\n    nextPosition.height = this.size.h;\n    var tiles = this.game.tiles;\n\n    for (var i = 0; i < tiles.length; i++) {\n      if (tiles[i].material == 'grass') {\n        continue;\n      }\n\n      var tilePosition = tiles[i].pos;\n      var tileBox = {};\n      tileBox.x = tilePosition.x;\n      tileBox.y = tilePosition.y;\n      tileBox.width = 32;\n      tileBox.height = 32;\n\n      if (this.intersectRect(nextPosition, tileBox, direction)) {\n        this.movePlayerCloser(direction, tilePosition);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  movePlayerCloser(direction, tilePosition) {\n    if (direction.x == 1 && direction.y == 0) {\n      this.pos.x = tilePosition.x - 24;\n      this.stop();\n    } else if (direction.x == -1 && direction.y == 0) {\n      // console.log(this.)\n      this.pos.x = tilePosition.x + 32;\n      this.stop();\n    } else if (direction.x == 0 && direction.y == 1) {\n      // console.log(this.)\n      this.pos.y = tilePosition.y - 24;\n      this.stop();\n    } else if (direction.x == 0 && direction.y == -1) {\n      // console.log(this.)\n      this.pos.y = tilePosition.y + 32;\n      this.stop();\n    }\n  }\n\n  removeFromArray(array, item) {\n    for (var i = 0; i < array.length; i++) {\n      if (item == array[i]) {\n        array.splice(i, 1);\n      }\n    }\n\n    return array;\n  }\n\n  setBombsListener() {\n    // Check whether there is already bomb on this position\n    for (var i = 0; i < this.game.bombs.length; i++) {\n      var bomb = this.game.bombs[i];\n\n      if (bomb.pos.x == this.pos.x && bomb.pos.y == this.pos.y) {\n        return;\n      }\n    }\n\n    var unexplodedBombs = 0;\n\n    for (var i = 0; i < this.bombs.length; i++) {\n      if (!this.bombs[i].exploded) {\n        unexplodedBombs++;\n      }\n    }\n\n    if (unexplodedBombs < this.bombsMax) {\n      var bomb = new _Bomb_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({ ...this.pos\n      }, this.bombStrength, this.game, this.bombSprite, this.fireSprite);\n      this.bombs.push(bomb);\n      this.game.bombs.push(bomb);\n      bomb.setExplodeListener(function () {});\n    }\n  }\n\n  handleBonusCollision() {\n    for (var i = 0; i < this.game.bonuses.length; i++) {\n      var bonus = this.game.bonuses[i];\n\n      if (this.intersectRect({ ...bonus.pos,\n        width: 32 - 2,\n        height: 32 - 2\n      }, { ...this.pos,\n        width: 24,\n        height: 24\n      })) {\n        // debugger\n        this.applyBonus(bonus);\n        bonus.remove();\n      }\n    }\n  }\n\n  applyBonus(bonus) {\n    if (bonus.type == 'speed') {\n      this.velocity += .25;\n    } else if (bonus.type == 'bomb') {\n      this.bombsMax++;\n    } else if (bonus.type == 'fire') {\n      this.bombStrength++;\n    }\n  }\n\n}\n\nfunction createPlayer(game) {\n  return Promise.all([Object(_sprites_js__WEBPACK_IMPORTED_MODULE_1__[\"loadPlayerSprite\"])(), Object(_sprites_js__WEBPACK_IMPORTED_MODULE_1__[\"loadBombSprite\"])(), Object(_sprites_js__WEBPACK_IMPORTED_MODULE_1__[\"loadFireSprite\"])()]).then(([playerSprite, bombSprite, fireSprite]) => {\n    return new Player({\n      playerSprite,\n      bombSprite,\n      fireSprite\n    }, game);\n  });\n}\n\n//# sourceURL=webpack:///./public/js/Player.js?");

/***/ }),

/***/ "./public/js/SpriteSheet.js":
/*!**********************************!*\
  !*** ./public/js/SpriteSheet.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SpriteSheet; });\nclass SpriteSheet {\n  constructor(image, width, height) {\n    this.image = image;\n    this.width = width;\n    this.height = height;\n    this.tiles = new Map();\n  }\n\n  define(name, x, y, width, height) {\n    const buffer = document.createElement('canvas');\n    buffer.width = width;\n    buffer.height = height;\n    buffer.getContext('2d').drawImage(this.image, x, y, width, height, 0, 0, width, height);\n    this.tiles.set(name, buffer);\n  }\n\n  defineTile(name, x, y) {\n    this.define(name, x * this.width, y * this.height, this.width, this.height);\n  }\n\n  draw(name, context, x, y) {\n    const buffer = this.tiles.get(name); // debugger\n\n    context.drawImage(buffer, x, y);\n  }\n\n  drawTile(name, context, x, y) {\n    this.draw(name, context, x * this.width, y * this.height);\n  }\n\n}\n\n//# sourceURL=webpack:///./public/js/SpriteSheet.js?");

/***/ }),

/***/ "./public/js/Tile.js":
/*!***************************!*\
  !*** ./public/js/Tile.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Tile; });\nclass Tile {\n  constructor(pos, material, game) {\n    this.pos = pos;\n    this.material = material;\n    this.game = game;\n  }\n\n  remove() {\n    for (var i = 0; i < this.game.tiles.length; i++) {\n      var tile = this.game.tiles[i];\n\n      if (this == tile) {\n        this.game.tiles.splice(i, 1);\n      }\n    }\n\n    this.game.updateBackground = true;\n  }\n\n}\n\n//# sourceURL=webpack:///./public/js/Tile.js?");

/***/ }),

/***/ "./public/js/layers.js":
/*!*****************************!*\
  !*** ./public/js/layers.js ***!
  \*****************************/
/*! exports provided: createBackgroundLayer, createSpriteLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createBackgroundLayer\", function() { return createBackgroundLayer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createSpriteLayer\", function() { return createSpriteLayer; });\n/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ \"./public/js/Tile.js\");\n/* harmony import */ var _Bonus_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bonus.js */ \"./public/js/Bonus.js\");\n\n\n\nfunction drawBonuses(context, sprites, woodsArray, game) {\n  let woods = [...woodsArray];\n  woods.sort(function () {\n    return 0.5 - Math.random();\n  });\n  let bonusesPercent = game.bonusesPercent;\n  let bonusTypes = ['speed', 'bomb', 'fire'];\n\n  for (var j = 0; j < 4; j++) {\n    var bonusesCount = Math.round(woods.length * bonusesPercent * 0.01 / 4);\n    var placedCount = 0;\n\n    for (var i = 0; i < woods.length; i++) {\n      if (placedCount > bonusesCount) {\n        break;\n      }\n\n      var tile = woods[i];\n\n      if (j == 0 && tile.pos.x < 32 / 2 && tile.pos.y < 32 / 2 || j == 1 && tile.pos.x < 32 / 2 && tile.pos.y > 32 / 2 || j == 2 && tile.pos.x > 32 / 2 && tile.pos.y < 32 / 2 || j == 3 && tile.pos.x > 32 / 2 && tile.pos.y > 32 / 2) {\n        var typePosition = bonusTypes[placedCount % 3];\n        var bonus = new _Bonus_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ ...tile.pos\n        }, typePosition, game);\n        game.bonuses.push(bonus);\n        sprites.woodSprite.draw('wood', context, tile.pos.x, tile.pos.y);\n        placedCount++;\n      }\n    }\n  }\n}\n\nfunction drawBackground(context, sprites, tiles, game) {\n  let bonusTypes = ['speed', 'bomb', 'fire'];\n  let woodArray = [];\n\n  for (var y = 0; y < 13; y++) {\n    for (var x = 0; x < 17; x++) {\n      if (y == 0 || x == 0 || y == 13 - 1 || x == 17 - 1 || x % 2 == 0 && y % 2 == 0) {\n        sprites.wallSprite.draw('wall', context, x * 32, y * 32);\n        tiles.push(new _Tile_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n          x: x * 32,\n          y: y * 32\n        }, 'wall', game));\n      } else {\n        sprites.grassSprite.draw('grass', context, x * 32, y * 32);\n\n        if (x > 3 && x < 13 && (y == 1 || y == 11)) {\n          sprites.woodSprite.draw('wood', context, x * 32, y * 32);\n          let woodTile = new _Tile_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            x: x * 32,\n            y: y * 32\n          }, 'wood', game);\n          tiles.push(woodTile);\n          woodArray.push(woodTile);\n        }\n\n        if ((y == 7 || y == 5) && !(x == 3 || x == 13)) {\n          sprites.woodSprite.draw('wood', context, x * 32, y * 32);\n          let woodTile = new _Tile_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            x: x * 32,\n            y: y * 32\n          }, 'wood', game);\n          tiles.push(woodTile);\n          woodArray.push(woodTile);\n        }\n\n        if (x == 3 || x == 13) {\n          sprites.woodSprite.draw('wood', context, x * 32, y * 32);\n          let woodTile = new _Tile_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            x: x * 32,\n            y: y * 32\n          }, 'wood', game);\n          tiles.push(woodTile);\n          woodArray.push(woodTile);\n        }\n      }\n    }\n  }\n\n  drawBonuses(context, sprites, woodArray, game);\n}\n\nfunction updateBackground(context, tiles, sprites, bonuses) {\n  bonuses.forEach(bonus => {\n    // bonus\n    bonus.draw(context);\n  });\n  tiles.forEach(tile => {\n    // debugger\n    if (tile.material == 'wood') {\n      sprites.woodSprite.draw('wood', context, tile.pos.x, tile.pos.y);\n    } else if (tile.material == 'wall') {\n      // debugger\n      sprites.wallSprite.draw('wall', context, tile.pos.x, tile.pos.y);\n    }\n  });\n}\n\nfunction drawGrassTiles(sprite, context) {\n  for (let x = 0; x < 17; x++) {\n    for (let y = 0; y < 13; y++) {\n      sprite.draw('grass', context, x * 32, y * 32);\n    }\n  }\n}\n\nfunction createBackgroundLayer(backgroundSprites, tiles, game) {\n  const buffer = document.createElement('canvas');\n  buffer.width = 816;\n  buffer.height = 624;\n  const GrassBuffer = document.createElement('canvas');\n  GrassBuffer.width = 816;\n  GrassBuffer.height = 624;\n  drawGrassTiles(backgroundSprites.grassSprite, GrassBuffer.getContext('2d'));\n  drawBackground(buffer.getContext('2d'), backgroundSprites, tiles, game);\n  return function drawBackgroundLayer(context) {\n    if (game.updateBackground) {\n      // console.log(game.bombs.length)\n      buffer.getContext('2d').drawImage(GrassBuffer, 0, 0);\n      updateBackground(buffer.getContext('2d'), tiles, backgroundSprites, game.bonuses);\n      game.updateBackground = false;\n    }\n\n    context.drawImage(buffer, 0, 0);\n  };\n}\nfunction createSpriteLayer(entity) {\n  return function drawSpriteLayer(context) {\n    entity.draw(context);\n  };\n}\n\n//# sourceURL=webpack:///./public/js/layers.js?");

/***/ }),

/***/ "./public/js/loaders.js":
/*!******************************!*\
  !*** ./public/js/loaders.js ***!
  \******************************/
/*! exports provided: loadImage, loadLevel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadImage\", function() { return loadImage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadLevel\", function() { return loadLevel; });\nfunction loadImage(url) {\n  return new Promise(resolve => {\n    const image = new Image();\n    image.addEventListener('load', () => {\n      resolve(image);\n    });\n    image.src = url;\n  });\n}\nfunction loadLevel(name) {\n  return fetch(`/levels/${name}.json`).then(r => r.json());\n}\n\n//# sourceURL=webpack:///./public/js/loaders.js?");

/***/ }),

/***/ "./public/js/sprites.js":
/*!******************************!*\
  !*** ./public/js/sprites.js ***!
  \******************************/
/*! exports provided: loadPlayerSprite, loadBombSprite, loadBonusSprite, loadGhostSprite, loadDeadSprite, loadFireSprite, loadBackgroundSprites */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadPlayerSprite\", function() { return loadPlayerSprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadBombSprite\", function() { return loadBombSprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadBonusSprite\", function() { return loadBonusSprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadGhostSprite\", function() { return loadGhostSprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadDeadSprite\", function() { return loadDeadSprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadFireSprite\", function() { return loadFireSprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadBackgroundSprites\", function() { return loadBackgroundSprites; });\n/* harmony import */ var _SpriteSheet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SpriteSheet.js */ \"./public/js/SpriteSheet.js\");\n/* harmony import */ var _loaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loaders.js */ \"./public/js/loaders.js\");\n\n\nfunction loadPlayerSprite() {\n  return Object(_loaders_js__WEBPACK_IMPORTED_MODULE_1__[\"loadImage\"])('./img/player.png').then(image => {\n    const player = new _SpriteSheet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](image, 24, 24);\n    player.define('idle', 0, 0, 24, 24);\n    player.define('left-0', 0, 24, 24, 24);\n    player.define('left-1', 24, 24, 24, 24);\n    player.define('left-2', 48, 24, 24, 24);\n    player.define('right-0', 0, 48, 24, 24);\n    player.define('right-1', 24, 48, 24, 24);\n    player.define('right-2', 48, 48, 24, 24);\n    player.define('down-0', 0, 0, 24, 24);\n    player.define('down-1', 24, 0, 24, 24);\n    player.define('down-2', 48, 0, 24, 24);\n    player.define('top-0', 0, 72, 24, 24);\n    player.define('top-1', 24, 72, 24, 24);\n    player.define('top-2', 48, 72, 24, 24);\n    return player;\n  });\n}\nfunction loadBombSprite() {\n  return Object(_loaders_js__WEBPACK_IMPORTED_MODULE_1__[\"loadImage\"])('./img/bomb.png').then(image => {\n    const bomb = new _SpriteSheet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](image, 28, 28);\n    bomb.define('bomb', 0, 0, 28, 28);\n    return bomb;\n  });\n}\nfunction loadBonusSprite() {\n  return Object(_loaders_js__WEBPACK_IMPORTED_MODULE_1__[\"loadImage\"])('./img/bonuses.png').then(image => {\n    const bonuses = new _SpriteSheet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](image, 32, 32);\n    bonuses.define('speed', 0, 0, 32, 32);\n    bonuses.define('bomb', 32, 0, 32, 32);\n    bonuses.define('fire', 64, 0, 32, 32);\n    return bonuses;\n  });\n}\nfunction loadGhostSprite() {\n  return Object(_loaders_js__WEBPACK_IMPORTED_MODULE_1__[\"loadImage\"])('./img/enemy.png').then(image => {\n    const ghost = new _SpriteSheet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](image, 24, 24);\n    ghost.define('ballon-1', 0, 24, 24, 24);\n    ghost.define('ballon-2', 24, 24, 24, 24);\n    ghost.define('ballon-3', 48, 24, 24, 24);\n    ghost.define('ballon-4', 0, 48, 24, 24);\n    ghost.define('ballon-5', 24, 48, 24, 24);\n    ghost.define('ballon-6', 48, 48, 24, 24);\n    return ghost;\n  });\n}\nfunction loadDeadSprite() {\n  return Object(_loaders_js__WEBPACK_IMPORTED_MODULE_1__[\"loadImage\"])('./img/dead.png').then(image => {\n    const ghost = new _SpriteSheet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](image, 32, 32);\n    ghost.define('dead-left-1', 0, 32 * 3, 32, 32);\n    ghost.define('dead-left-2', 32, 32 * 3, 32, 32);\n    ghost.define('dead-left-3', 32 * 2, 32 * 3, 32, 32);\n    ghost.define('dead-right-1', 0, 32, 32, 32);\n    ghost.define('dead-right-2', 32, 32, 32, 32);\n    ghost.define('dead-right-3', 32 * 2, 32, 32, 32);\n    ghost.define('dead-top-1', 0, 0, 32, 32);\n    ghost.define('dead-top-2', 32, 0, 32, 32);\n    ghost.define('dead-top-3', 32 * 2, 0, 32, 32);\n    ghost.define('dead-down-1', 0, 64, 32, 32);\n    ghost.define('dead-down-2', 32, 64, 32, 32);\n    ghost.define('dead-down-3', 32 * 2, 64, 32, 32);\n    return ghost;\n  });\n}\nfunction loadFireSprite() {\n  return Object(_loaders_js__WEBPACK_IMPORTED_MODULE_1__[\"loadImage\"])('./img/fire.png').then(image => {\n    const fire = new _SpriteSheet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](image, 28, 28);\n    fire.define('fire', 0, 0, 28, 28);\n    return fire;\n  });\n}\n\nfunction loadGrassSprite() {\n  return Object(_loaders_js__WEBPACK_IMPORTED_MODULE_1__[\"loadImage\"])('./img/tile_grass.png').then(image => {\n    const grass = new _SpriteSheet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](image, 32, 32);\n    grass.define('grass', 0, 0, 32, 32);\n    return grass;\n  });\n}\n\nfunction loadWallSprite() {\n  return Object(_loaders_js__WEBPACK_IMPORTED_MODULE_1__[\"loadImage\"])('./img/tile_wall.png').then(image => {\n    const wall = new _SpriteSheet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](image, 32, 32);\n    wall.define('wall', 0, 0, 32, 32);\n    return wall;\n  });\n}\n\nfunction loadWoodSprite() {\n  return Object(_loaders_js__WEBPACK_IMPORTED_MODULE_1__[\"loadImage\"])('./img/tile_wood.png').then(image => {\n    const wood = new _SpriteSheet_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](image, 32, 32);\n    wood.define('wood', 0, 0, 32, 32);\n    return wood;\n  });\n} // Promise.all([\n//     loadGrassSprite(),\n//     loadWallSprite(),\n//     loadWoodSprite(),\n// ])\n// .then(([grassSprite, wallSprite, woodSprite]) => {\n// })\n\n\nfunction loadBackgroundSprites() {\n  return Promise.all([loadGrassSprite(), loadWallSprite(), loadWoodSprite()]).then(([grassSprite, wallSprite, woodSprite]) => {\n    return {\n      grassSprite,\n      wallSprite,\n      woodSprite\n    };\n  });\n}\n\n//# sourceURL=webpack:///./public/js/sprites.js?");

/***/ })

/******/ });